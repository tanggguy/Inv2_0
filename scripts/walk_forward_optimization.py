#!/usr/bin/env python3
"""
Walk-Forward Optimization - VERSION CORRIG√âE
G√®re les cas o√π aucun trade n'est effectu√©
"""

import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

import pandas as pd
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta

from scripts.optimize_strategy import StrategyOptimizer
from backtesting.backtest_engine import BacktestEngine
from strategies.marsi import MaSuperStrategie
from monitoring.logger import setup_logger

logger = setup_logger("walk_forward")


class WalkForwardOptimizer:
    """Optimisation Walk-Forward pour √©viter l'overfitting"""

    def __init__(
        self,
        strategy_class,
        symbols,
        in_sample_months=12,
        out_sample_months=3,
        start_date="2020-01-01",
        end_date="2024-01-01",
    ):

        self.strategy_class = strategy_class
        self.symbols = symbols
        self.in_sample_months = in_sample_months
        self.out_sample_months = out_sample_months
        self.start_date = pd.to_datetime(start_date)
        self.end_date = pd.to_datetime(end_date)

        self.periods = []
        self.results = []

    def generate_periods(self):
        """G√©n√®re les p√©riodes In-Sample et Out-Sample"""

        current_date = self.start_date

        while (
            current_date
            + relativedelta(months=self.in_sample_months + self.out_sample_months)
            <= self.end_date
        ):

            # P√©riode In-Sample
            in_start = current_date
            in_end = current_date + relativedelta(months=self.in_sample_months)

            # P√©riode Out-Sample
            out_start = in_end
            out_end = out_start + relativedelta(months=self.out_sample_months)

            self.periods.append(
                {
                    "in_sample": (
                        in_start.strftime("%Y-%m-%d"),
                        in_end.strftime("%Y-%m-%d"),
                    ),
                    "out_sample": (
                        out_start.strftime("%Y-%m-%d"),
                        out_end.strftime("%Y-%m-%d"),
                    ),
                }
            )

            # Avancer
            current_date = out_start

        logger.info(f"‚úì {len(self.periods)} p√©riodes g√©n√©r√©es")
        return self.periods

    def run_walk_forward(self, param_grid):
        """Ex√©cute le walk-forward complet"""

        print("\n" + "=" * 80)
        print("üö∂ WALK-FORWARD OPTIMIZATION")
        print("=" * 80)
        print(f"In-Sample: {self.in_sample_months} mois")
        print(f"Out-Sample: {self.out_sample_months} mois")
        print(f"P√©riodes totales: {len(self.periods)}")
        print("=" * 80 + "\n")

        for i, period in enumerate(self.periods, 1):
            print(f"\n{'='*80}")
            print(f"P√âRIODE {i}/{len(self.periods)}")
            print(f"{'='*80}")

            in_start, in_end = period["in_sample"]
            out_start, out_end = period["out_sample"]

            print(f"üìä In-Sample:  {in_start} ‚Üí {in_end}")
            print(f"üìà Out-Sample: {out_start} ‚Üí {out_end}\n")

            # 1. Optimiser sur In-Sample
            print("üî¨ Optimisation sur In-Sample...")
            optimizer = StrategyOptimizer(
                strategy_class=self.strategy_class,
                symbols=self.symbols,
                start_date=in_start,
                end_date=in_end,
                capital=100000,
            )

            best_params = optimizer.optimize(param_grid)

            if not best_params:
                logger.warning(f"Pas de r√©sultats pour p√©riode {i} (In-Sample)")
                continue

            # Extraire les param√®tres (sans les m√©triques)
            strategy_params = {
                k: v
                for k, v in best_params.items()
                if k not in ["sharpe", "return", "drawdown", "trades", "win_rate"]
            }

            # Valeurs par d√©faut si None
            in_sharpe = best_params.get("sharpe", 0) or 0
            in_return = best_params.get("return", 0) or 0

            print(f"\n‚úì Meilleurs param√®tres In-Sample: {strategy_params}")
            print(f"  Sharpe: {in_sharpe:.2f}")
            print(f"  Return: {in_return:.2f}%")

            # 2. Tester sur Out-Sample avec ces param√®tres
            print(f"\nüß™ Test sur Out-Sample...")

            engine = BacktestEngine(
                strategy_name=self.strategy_class.__name__,
                symbols=self.symbols,
                start_date=out_start,
                end_date=out_end,
                initial_capital=100000,
                verbose=False,
            )

            out_results = engine.run()

            # ===== GESTION DES CAS PROBL√âMATIQUES =====
            if out_results:
                # Valeurs par d√©faut si None
                out_sharpe = out_results.get("sharpe_ratio") or 0
                out_return = out_results.get("total_return") or 0
                out_trades = out_results.get("total_trades", 0)

                print(f"‚úì R√©sultats Out-Sample:")
                print(f"  Sharpe: {out_sharpe:.2f}")
                print(f"  Return: {out_return:.2f}%")
                print(f"  Trades: {out_trades}")

                # V√©rifier si des trades ont √©t√© effectu√©s
                if out_trades == 0:
                    print(f"  ‚ö†Ô∏è  AUCUN TRADE - P√©riode ignor√©e dans l'analyse")
                    logger.warning(f"P√©riode {i}: Aucun trade en Out-Sample")
                    continue

                # Calculer la d√©gradation (g√©rer les None)
                degradation = in_sharpe - out_sharpe

                # Stocker les r√©sultats
                self.results.append(
                    {
                        "period": i,
                        "in_sample_start": in_start,
                        "in_sample_end": in_end,
                        "out_sample_start": out_start,
                        "out_sample_end": out_end,
                        "params": strategy_params,
                        "in_sample_sharpe": in_sharpe,
                        "in_sample_return": in_return,
                        "out_sample_sharpe": out_sharpe,
                        "out_sample_return": out_return,
                        "out_sample_trades": out_trades,
                        "degradation": degradation,
                    }
                )
            else:
                logger.warning(f"P√©riode {i}: Pas de r√©sultats Out-Sample")
                print(f"  ‚ö†Ô∏è  Pas de r√©sultats - P√©riode ignor√©e")

        # Analyser les r√©sultats
        if self.results:
            self._analyze_walk_forward()
        else:
            print("\n" + "=" * 80)
            print("‚ùå AUCUN R√âSULTAT VALIDE")
            print("=" * 80)
            print("\nProbl√®mes possibles:")
            print("  ‚Ä¢ P√©riode trop courte (pas assez de trades)")
            print("  ‚Ä¢ Param√®tres trop restrictifs")
            print("  ‚Ä¢ Strat√©gie ne g√©n√®re pas de signaux")
            print("\nRecommandations:")
            print("  ‚Ä¢ Augmenter la dur√©e des p√©riodes")
            print("  ‚Ä¢ Assouplir les conditions d'entr√©e")
            print("  ‚Ä¢ V√©rifier les param√®tres de la strat√©gie")

    def _analyze_walk_forward(self):
        """Analyse les r√©sultats du walk-forward"""

        if not self.results:
            logger.error("Aucun r√©sultat √† analyser")
            return

        df = pd.DataFrame(self.results)

        print("\n" + "=" * 80)
        print("üìä ANALYSE WALK-FORWARD")
        print("=" * 80)

        # Filtrer les p√©riodes sans trades
        valid_periods = len(df)
        total_periods = len(self.periods)

        print(f"\nüìà COUVERTURE:")
        print(f"   P√©riodes totales: {total_periods}")
        print(f"   P√©riodes valides: {valid_periods}")
        print(f"   Taux de couverture: {valid_periods/total_periods*100:.1f}%")

        if valid_periods < total_periods * 0.5:
            print(f"   ‚ö†Ô∏è  ATTENTION: Moins de 50% de couverture")
            print(f"      ‚Üí Strat√©gie trop restrictive ou p√©riodes trop courtes")

        # Statistiques globales
        print("\nüéØ PERFORMANCE MOYENNE:")
        print(
            f"   In-Sample Sharpe:   {df['in_sample_sharpe'].mean():.2f} (¬±{df['in_sample_sharpe'].std():.2f})"
        )
        print(
            f"   Out-Sample Sharpe:  {df['out_sample_sharpe'].mean():.2f} (¬±{df['out_sample_sharpe'].std():.2f})"
        )
        print(f"   In-Sample Return:   {df['in_sample_return'].mean():.2f}%")
        print(f"   Out-Sample Return:  {df['out_sample_return'].mean():.2f}%")
        print(f"   Trades Out-Sample:  {df['out_sample_trades'].mean():.1f}")

        # D√©gradation
        avg_degradation = df["degradation"].mean()
        print(f"\nüìâ D√âGRADATION MOYENNE: {avg_degradation:.2f}")

        if avg_degradation < 0.3:
            print("   ‚úÖ EXCELLENT - Strat√©gie robuste, peu d'overfitting")
        elif avg_degradation < 0.5:
            print("   ‚úì BON - D√©gradation acceptable")
        elif avg_degradation < 0.8:
            print("   ‚ö†Ô∏è  MOYEN - Attention √† l'overfitting")
        else:
            print("   ‚ùå MAUVAIS - Fort overfitting d√©tect√©")

        # Tableau d√©taill√©
        print("\n" + "=" * 80)
        print("üìã R√âSULTATS PAR P√âRIODE")
        print("=" * 80)

        summary = df[
            [
                "period",
                "in_sample_sharpe",
                "out_sample_sharpe",
                "in_sample_return",
                "out_sample_return",
                "out_sample_trades",
                "degradation",
            ]
        ]
        print(summary.to_string(index=False))

        # Sauvegarder
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        from config import settings

        results_file = settings.RESULTS_DIR / f"walk_forward_{timestamp}.csv"
        df.to_csv(results_file, index=False)

        print(f"\n‚úÖ R√©sultats sauvegard√©s: {results_file}")

        # Recommandations
        print("\n" + "=" * 80)
        print("üí° RECOMMANDATIONS")
        print("=" * 80)

        # V√©rifier si assez de p√©riodes valides
        if valid_periods < 3:
            print("\n‚ö†Ô∏è  ATTENTION: Trop peu de p√©riodes valides")
            print("‚Üí Augmenter la p√©riode In-Sample (ex: 18 mois)")
            print("‚Üí Augmenter la p√©riode Out-Sample (ex: 6 mois)")
            print("‚Üí Assouplir les conditions de la strat√©gie")
            return

        # Analyser la performance Out-Sample
        avg_out_sharpe = df["out_sample_sharpe"].mean()

        if avg_out_sharpe > 1.0:
            print("‚úì La strat√©gie est robuste et rentable")

            if avg_degradation < 0.5:
                print("‚úì Pas d'overfitting significatif")
                print("‚úÖ PR√äT POUR LE PAPER TRADING")
            else:
                print("‚ö†Ô∏è  Overfitting d√©tect√© mais performance acceptable")
                print("‚Üí Simplifier la strat√©gie si possible")
        else:
            print("‚ö†Ô∏è  Performance Out-Sample insuffisante")
            print("‚Üí Ajuster les param√®tres ou changer de strat√©gie")

        if avg_degradation > 0.5:
            print("\n‚ö†Ô∏è  Overfitting d√©tect√©:")
            print("‚Üí Simplifier la strat√©gie (moins de param√®tres)")
            print("‚Üí Augmenter la p√©riode In-Sample")
            print("‚Üí Tester sur plus de symboles")

        # Analyse de stabilit√©
        sharpe_std = df["out_sample_sharpe"].std()
        if sharpe_std > 1.0:
            print("\n‚ö†Ô∏è  Performance instable entre p√©riodes")
            print(f"   √âcart-type Sharpe: {sharpe_std:.2f}")
            print("‚Üí Strat√©gie potentiellement non robuste")


def main():
    """Exemple d'utilisation"""

    print(
        """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            üö∂ WALK-FORWARD OPTIMIZATION üö∂                           ‚ïë
‚ïë                                                                       ‚ïë
‚ïë        Validation robuste pour √©viter le surapprentissage           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """
    )

    # Configuration
    wf_optimizer = WalkForwardOptimizer(
        strategy_class=MaSuperStrategie,
        symbols=["AAPL"],
        in_sample_months=24,  # 12 mois pour optimiser
        out_sample_months=6,  # 3 mois pour tester
        start_date="2015-01-01",
        end_date="2025-01-01",
    )
    # Grille de param√®tres (r√©duite pour walk-forward)
    param_grid = {
        "ma_period": [20, 30, 50],
        "rsi_period": [14, 21],
        "stop_loss_pct": [0.02, 0.025],
    }
    # G√©n√©rer les p√©riodes
    periods = wf_optimizer.generate_periods()

    print(f"\nüìÖ P√©riodes g√©n√©r√©es:")
    for i, p in enumerate(periods, 1):
        print(
            f"   {i}. In: {p['in_sample'][0]} ‚Üí {p['in_sample'][1]} | "
            f"Out: {p['out_sample'][0]} ‚Üí {p['out_sample'][1]}"
        )

    print(f"\n‚öôÔ∏è  Grille de param√®tres: {param_grid}")

    from itertools import product

    total_combos = 1
    for values in param_grid.values():
        total_combos *= len(values)
    print(f"   Total combinaisons par p√©riode: {total_combos}")
    print(f"   Total tests: {len(periods) * total_combos}")

    # Confirmation
    print("\n" + "=" * 70)
    confirm = input("‚ñ∂ Lancer l'optimisation ? (o/n) [o]: ").strip().lower() or "o"

    if confirm != "o":
        print("Optimisation annul√©e")
        return

    # Lancer
    wf_optimizer.run_walk_forward(param_grid)


if __name__ == "__main__":
    main()
